*,
::after,
::before {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --flex-item-color: #9aa559;
  --flex-item-border-color: rgb(165, 46, 119);
}

html {
  font-family: sans-serif;
}

/* Setting the section heights to a % requires we define the
height of their parent, which is the body. */
body {
  background-color: #ccc;
  margin: 10px;
  height: 100vh;
}

ul {
  list-style: none;
  
}

h2.main-title {
  font-size: 1.2rem;
  font-weight: bold;
  height: 1rem;
  margin: 10px 0;
  text-align: center;
  width: 100%;
}

/* This wrapper encompasses all elements, so you must set both its width and height so the children can reference off these values.  For example, by not setting a height, the wrapper takes the height of the content only.  This wrappers parent is the <body> which is full viewport, and the wrapper should also be full viewport.  The result is that the second row (of <sections> can establish their height based on a % of their parent which is this wrapper */
/* Using inline-block for all <section> tags allows converting
typical block level elements to inline, thus displaying them in a single row (which will wrap in smaller viewports).  Unlike pure 'inline', this also permits a width/height to be set, plus using floats to push specific elements to either side. */
div.main-wrapper {
  width: 100%;
  height: 100%;
  display: inline-block;
}

#panel-wrapper {
  /* width: 75%; */
  height: 433px;
  background-color: #666;
}


/* Wrapper for both Settings blocks.  Since the main-wrapper is inline, and there is a block keeping to the left edge (CSS Result) block, we move this section to the right by using position:relative (to its original position)*/
/* Float:left allows positioning of an inline/inline-block element to the left side of the parent element.  Since the previous element in the DOM is a block level element, this <section> takes up the left edge of the second row of DOM elements */

ul#panel-list{
    display:inline;
}


/* Vertical-Align:top saved the entire layout from being ruined after I removed the overflow from the panels.   Whew */
li.panel {
    display: inline-block;
    vertical-align: top;
    background-color: slategray;

  /* width: 24%; */
  margin-right: 5px;
  border: 1px solid #222;
  width: 300px;
  height: 430px;
  min-width: 300px;
  max-width: 300px;
}

#media-queries{
    
}


#css-panel{
    /* border: 1px solid red; */
    /* height:360px; */
    min-width: 100px;
    max-width: none;
    width: calc(100% - 930px);
    /* background-color: red; */
    margin-right: 0;
    /* background:indigo; */
    /* font-family: monospace; */
    
}

#css-output{
    font-family:monospace;
    height: 357px;
    border-bottom:1px solid green;

}

.button-set{
    background:slategray;
    padding:8px;
    padding-left:12px;
    display:inline-block;
    width:100%;
}

.button-set button{
    display:inherit;
    width:30%;
    margin-right:5px;
    border-radius:6px;
    padding:4px 0px;
}

#flex-container-buttons{
    margin-top:90px;
 
}

#flex-item-buttons{
    margin-top:9px;
}

#flex-item-buttons{
    margin-top:9px;
}

#css-output-buttons{
    margin-top:4px;
}




li.input-field,
li.dimensions {
  padding: 4px;
  width: 100%;
  display: inline-block;
  
}

li.input-field label {
    /* background:coral; */
  display: inherit;
  width: 130px;
}
li.input-field .setting-item {
  display: inherit;
  width: 148px;
}

li.dimensions > label {
  /* border:1px solid red; */
  display: inherit;
  width: 112px;
}

li.dimensions input[type='number'] {
  width: 50px;
}

li.flex-item-checkbox{
    display:inline-block;
    padding-top:8px;
}
div.checkbox-wrapper{
  background:black;
  color:white;
  margin-top:0;
}
li.flex-item-checkbox label{
      width:20px;
      padding:0px 20px;
      /* vertical-align: middle; */
      /* height:20px; */
  }


/* Position absolute ignores DOM element ordering of elements and sets up a new positioning context where this element is positioned based on its nearest neighbor in the layout that has its position property set. */




textarea#media-queries{
    width:calc(100% - 8px);
    margin:0px 4px;
    height:356px;
}



/* The buttons are positioned by setting their position:relative which allows me to adjust the top by pixels until it is displayed at the bottom of the panel (which is not adjustable.   The original top is determined by its relationship to adjacent DOM elements */
li.button-set#media-query-buttons{
  position:relative;
top:48px;



}

/* Display:block us used for an otherwise inline element (<span>) in order to center the text inside the containing <section>  */
span.section-title {
   
  display: block;
  width: 100%;
  text-align: center;
  font-weight: bold;
  margin-bottom: 0.3rem;
  background-color: black;
  color: white;
}

/*I ended up wrapping the <textare> in a div.flex-items-settings-block in order to style each repeating block of controls used to manipulate individual flex-items in the parent layout.  The wrapping <div> needed to be reduced by 1.4rem to make up for the left margin set on the <ol> which effectively shifted the entire <ol> to the right, truncating the width of the <li> in the <ol> and their respetive contents. */
#flex-item-settings textarea {
  margin-bottom: 5px;
  width: 100%;
  overflow: scroll;
  text-align: center;
}

ul.containers-list{
    /* position:relative; */
    /* display:inline-block; */
    width:100%;
    align-items:top;
}

ul.containers-list li{
    display:inline-block;
}
ul.containers-list li.portrait{
    width:calc(20% - 6px);
    max-width:400px;
}

ul.containers-list li.landscape{
    width:80%;
}

/* At the bottom is a full-width flex container */
div.flex-container#landscape {
  position: relative;
  border: 1px solid black;
  width:100%;
  top:4px;
  


}
/* Inside the full-width flex container are children (ie flex-items */
div.flex-items {
  border: 1px solid var(--flex-item-border-color);
  background-color: var(--flex-item-color);
  height: 80px;
  width: 80px;
}

/* This rule is for the content of each flex-item.  By default, a span is inline, so setting the display to block permits assigning an explicit width/height ()which is based on the parent container, in this case the div.flex-items which wraps this span.    If you just put a single char (like a numeric value), then padding-vertical:40% will get it to about the middle of the element.  Otherwise, the content should flow and size according to its specified width/height. */
span.flex-item-content {
  border: 1px solid orange;
  width: 100%;
  height: 100%;
  display: block;
  text-align: center;
  padding: 40% 0;
}

/* Reaching out to the list of <textarea> elements in the <ol> of section.flex-item-settings, we align the center of the initial <texarea> box with the numerica prefix of the <ol> using the vertical-align:middle.   MDN docs say this applies to inline, inline-block and table-cell boxes only.  It works here, so probably b/c <textarea> are inline-block??.

Although the default width of <textarea> is determined by its 'cols' attribute, setting its visible width is possible. 



/* This is a block level element as the final member of a row with 2 inline-block elements.   By setting its width to only 30% and float:right, it is positioned flush with the right edge of the parent container (div.main-wrapper).   We manually set the height to the same value used by the <section> rule above. */
div.flex-container#portrait {
  /* position: relative; */
  /* top:0; */
  width:100%;
  max-width:500px;
  height: 500px;
  /* height: 100%; */
  /* float:right; */
  top: 0px;
  /* left:75%; */
  border: 1px solid black;
  /* float: right; */

  /* height: 80%; */
}

div.flex-setting {
  padding: 0.3rem;
}

div.flex-item-settings-block {
  /* width:calc(100% - 1.4rem); */
  border: 1px solid #666;
  padding: 0.3rem;
}

div.flex-item-choices {
  padding: 0.3rem;
}



/* Normally <li> are block level elements (take up the full width), but for this array of items, it should be arrange horizontally, so display:inline-block works best, allowing also to set width/height values for each one. */
div.flex-items-checked li.flex-item-checkbox {
  order: 1px solid goldenrod;
  display: inline-block;
  width: 20%;
}

div.button-container {
  width: 100%;
  padding: 8px;
  border: 1px solid #555;
}

.button {
  width: 30%;
}

.flex-container#landscape{
    background:indigo;
}

.flex-container#portrait{
    background:khaki;
}

/* li.dimensions.flex-container input[type=checkbox]{
    background-color: coral;
   border-color:red;
   width:200px;
} */


