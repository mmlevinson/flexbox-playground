*,
::after,
::before {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --flex-item-color: #9aa559;
  --flex-item-border-color: rgb(165, 46, 119);
}

html {
  font-family: sans-serif;
}

/* Setting the section heights to a % requires we define the
height of their parent, which is the body. */
body {
  background-color: #ccc;
  margin: 10px;
  height: 100vh;
}

h2.main-title {
  font-size: 1.2rem;
  font-weight: bold;
  height: 1rem;
  margin: 10px 0;
  text-align: center;
  width: 100%;
}

/* This wrapper encompasses all elements, so you must set both its width and height so the children can reference off these values.  For example, by not setting a height, the wrapper takes the height of the content only.  This wrappers parent is the <body> which is full viewport, and the wrapper should also be full viewport.  The result is that the second row (of <sections> can establish their height based on a % of their parent which is this wrapper */
/* Using inline-block for all <section> tags allows converting
typical block level elements to inline, thus displaying them in a single row (which will wrap in smaller viewports).  Unlike pure 'inline', this also permits a width/height to be set, plus using floats to push specific elements to either side. */
div.main-wrapper {
  width: 100%;
  height: 100%;
  /* display: inline-block; */
}

#panel-wrapper {
  width: 100%;
}

#panel-wrapper ul li {
  
  display: inline-block;
  width: 24%;
  margin-right: 4px;
}

/* Wrapper for both Settings blocks.  Since the main-wrapper is inline, and there is a block keeping to the left edge (CSS Result) block, we move this section to the right by using position:relative (to its original position)*/
/* Float:left allows positioning of an inline/inline-block element to the left side of the parent element.  Since the previous element in the DOM is a block level element, this <section> takes up the left edge of the second row of DOM elements */

.panel {
  border: 1px solid #222;
  width: 300px;
  height: 30rem;
  min-width: 300px;
  max-width: 300px;
  overflow: scroll;
}

.panel#narrow-layout {
  min-width: 100px;
  max-width: none;
  width: calc(100% - 930px);
  background-color: red;
  margin-right:0;
}

#flex-container-settings {
  border: 1px solid green;
}

/* Position absolute ignores DOM element ordering of elements and sets up a new positioning context where this element is positioned based on its nearest neighbor in the layout that has its position property set. */
#flex-item-settings {
  border-left: 1px solid black;
}

#css-output pre {
  font-family: monospace;
}

/* Display:block us used for an otherwise inline element (<span>) in order to center the text inside the containing <section>  */
span.section-title {
  display: block;
  width: 100%;
  text-align: center;
  font-weight: bold;
  margin-bottom: 0.3rem;
  background-color: black;
  color: white;
}

/*I ended up wrapping the <textare> in a div.flex-items-settings-block in order to style each repeating block of controls used to manipulate individual flex-items in the parent layout.  The wrapping <div> needed to be reduced by 1.4rem to make up for the left margin set on the <ol> which effectively shifted the entire <ol> to the right, truncating the width of the <li> in the <ol> and their respetive contents. */
section#flex-item-settings textarea {
  margin-bottom: 0.3rem;
  width: 100%;
  text-align: center;
}

/* At the bottom is a full-width flex container */
div.flex-container#wide {
  position: relative;
  border: 1px solid black;
  height: 1000px;
  display: flex;
}
/* Inside the full-width flex container are children (ie flex-items */
div.flex-items {
  border: 1px solid var(--flex-item-border-color);
  background-color: var(--flex-item-color);
  height: 100px;
  width: 100px;
}

/* This rule is for the content of each flex-item.  By default, a span is inline, so setting the display to block permits assigning an explicit width/height ()which is based on the parent container, in this case the div.flex-items which wraps this span.    If you just put a single char (like a numeric value), then padding-vertical:40% will get it to about the middle of the element.  Otherwise, the content should flow and size according to its specified width/height. */
span.flex-item-content {
  border: 1px solid orange;
  width: 100%;
  height: 100%;
  display: block;
  text-align: center;
  padding: 40% 0;
}

/* Reaching out to the list of <textarea> elements in the <ol> of section.flex-item-settings, we align the center of the initial <texarea> box with the numerica prefix of the <ol> using the vertical-align:middle.   MDN docs say this applies to inline, inline-block and table-cell boxes only.  It works here, so probably b/c <textarea> are inline-block??.

Although the default width of <textarea> is determined by its 'cols' attribute, setting its visible width is possible. 



/* This is a block level element as the final member of a row with 2 inline-block elements.   By setting its width to only 30% and float:right, it is positioned flush with the right edge of the parent container (div.main-wrapper).   We manually set the height to the same value used by the <section> rule above. */
div.flex-container#narrow {
  position: relative;
  height: 100%;
  /* float:right; */
  /* top: 0px; */
  /* left:75%; */
  border: 1px solid black;
  /* float: right; */

  /* height: 80%; */
}

div.flex-setting {
  padding: 0.3rem;
}

div.flex-item-settings-block {
  /* width:calc(100% - 1.4rem); */
  border: 1px solid #666;
  padding: 0.3rem;
}

div.flex-item-choices {
  padding: 0.3rem;
}

/* I tried text-align center and it worked.   This aligned the checkboxes into the center of their container div.    */
div.flex-items-checked {
  width: 100%;
  /* border:1px solid goldenrod; */
  text-align: center;
  padding: 1rem;
}

/* Normally <li> are block level elements (take up the full width), but for this array of items, it should be arrange horizontally, so display:inline-block works best, allowing also to set width/height values for each one. */
li.flex-item-checkbox {
  display: inline-block;
  width: 20%;
}

div.button-container {
  width: 100%;
  padding: 8px;
  border: 1px solid #555;
}

.button {
  width: 30%;
}

div.dimensions {
  padding: 6px;
}

span.dimension-inputs input {
  width: 3rem;
}
