*,
::after,
::before {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --flex-item-color: #9aa559;
  --flex-item-border-color: rgb(165, 46, 119);
}

html {
  font-family: sans-serif;
}

/* Setting the section heights to a % requires we define the
height of their parent, which is the body. */
body {
  background-color: #ccc;
  margin: 10px;
  height: 100vh;
}

ul {
  list-style-type: none;
}

h2.main-title {
  font-size: 1.2rem;
  font-weight: bold;
  height: 1rem;
  margin: 10px 0;
  text-align: center;
  width: 100%;
}

/* This wrapper encompasses all elements, so you must set both its width and height so the children can reference off these values.  For example, by not setting a height, the wrapper takes the height of the content only.  This wrappers parent is the <body> which is full viewport, and the wrapper should also be full viewport.  The result is that the second row (of <sections> can establish their height based on a % of their parent which is this wrapper */
/* Using inline-block for all <section> tags allows converting
typical block level elements to inline, thus displaying them in a single row (which will wrap in smaller viewports).  Unlike pure 'inline', this also permits a width/height to be set, plus using floats to push specific elements to either side. */
div.main-wrapper {
  width: 100%;
  height: 100%;
  /* display: inline-block; */
}

#panel-wrapper {
  width: 100%;
}


/* Wrapper for both Settings blocks.  Since the main-wrapper is inline, and there is a block keeping to the left edge (CSS Result) block, we move this section to the right by using position:relative (to its original position)*/
/* Float:left allows positioning of an inline/inline-block element to the left side of the parent element.  Since the previous element in the DOM is a block level element, this <section> takes up the left edge of the second row of DOM elements */

li.panel {
  display: inline-block;
  /* width: 24%; */
  margin-right: 4px;
  border: 1px solid #222;
  width: 300px;
  height: 400px;
  min-width: 300px;
  max-width: 300px;
  overflow: scroll;
}

/* To make the last panel resizable with the window, it was necessary to calc() the width using an empiric measurement subtracted from 100% */
li.panel#narrow-layout {
  min-width: 100px;
  max-width: none;
  width: calc(100% - 950px);
  background-color: red;
  margin-right: 0;
}

li.button-set{
    background:slategray;
    padding:8px;
    padding-left:12px;
    display:inline-block;
    width:100%;
}

li.button-set#flex-container-buttons{
    margin-top:52px;
}

li.button-set#flex-item-buttons{
    margin-top:11px;
}

li.button-set button{
    display:inherit;
    width:30%;
    margin-right:5px;
}

li.input-field,
li.dimensions {
  padding: 4px;
  width: 100%;
  display: inline-block;
}

li.input-field label {
    /* background:coral; */
  display: inherit;
  width: 48%;
}
li.input-field .setting-item {
  display: inherit;
  width: 50%;
}

li.dimensions > label {
  /* border:1px solid red; */
  display: inherit;
  width: 90px;
}

li.dimensions input[type='number'] {
  width: 54px;
}

li.flex-item-checkbox{
    display:inline-block;
    padding-top:8px;
}
div.checkbox-wrapper{
  background:black;
  color:white;
  margin-top:0;
}
li.flex-item-checkbox label{
      width:20px;
      padding:0px 20px;
      /* vertical-align: middle; */
      /* height:20px; */
  }

#flex-container-settings {
  border: 1px solid green;
}

/* Position absolute ignores DOM element ordering of elements and sets up a new positioning context where this element is positioned based on its nearest neighbor in the layout that has its position property set. */
#flex-item-settings {
  border-left: 1px solid black;
}

#css-output pre {
  font-family: monospace;
}

/* Display:block us used for an otherwise inline element (<span>) in order to center the text inside the containing <section>  */
span.section-title {
  display: block;
  width: 100%;
  text-align: center;
  font-weight: bold;
  margin-bottom: 0.3rem;
  background-color: black;
  color: white;
}

/*I ended up wrapping the <textare> in a div.flex-items-settings-block in order to style each repeating block of controls used to manipulate individual flex-items in the parent layout.  The wrapping <div> needed to be reduced by 1.4rem to make up for the left margin set on the <ol> which effectively shifted the entire <ol> to the right, truncating the width of the <li> in the <ol> and their respetive contents. */
section#flex-item-settings textarea {
  margin-bottom: 0.3rem;
  width: 100%;
  overflow: scroll;
  text-align: center;
}

/* At the bottom is a full-width flex container */
div.flex-container#wide {
  position: relative;
  border: 1px solid black;
  /* height: 1000px; */
  display: flex;
}
/* Inside the full-width flex container are children (ie flex-items */
div.flex-items {
  border: 1px solid var(--flex-item-border-color);
  background-color: var(--flex-item-color);
  height: 100px;
  width: 100px;
}

/* This rule is for the content of each flex-item.  By default, a span is inline, so setting the display to block permits assigning an explicit width/height ()which is based on the parent container, in this case the div.flex-items which wraps this span.    If you just put a single char (like a numeric value), then padding-vertical:40% will get it to about the middle of the element.  Otherwise, the content should flow and size according to its specified width/height. */
span.flex-item-content {
  border: 1px solid orange;
  width: 100%;
  height: 100%;
  display: block;
  text-align: center;
  padding: 40% 0;
}

/* Reaching out to the list of <textarea> elements in the <ol> of section.flex-item-settings, we align the center of the initial <texarea> box with the numerica prefix of the <ol> using the vertical-align:middle.   MDN docs say this applies to inline, inline-block and table-cell boxes only.  It works here, so probably b/c <textarea> are inline-block??.

Although the default width of <textarea> is determined by its 'cols' attribute, setting its visible width is possible. 



/* This is a block level element as the final member of a row with 2 inline-block elements.   By setting its width to only 30% and float:right, it is positioned flush with the right edge of the parent container (div.main-wrapper).   We manually set the height to the same value used by the <section> rule above. */
div.flex-container#narrow {
  position: relative;
  height: 100%;
  /* float:right; */
  /* top: 0px; */
  /* left:75%; */
  border: 1px solid black;
  /* float: right; */

  /* height: 80%; */
}

div.flex-setting {
  padding: 0.3rem;
}

div.flex-item-settings-block {
  /* width:calc(100% - 1.4rem); */
  border: 1px solid #666;
  padding: 0.3rem;
}

div.flex-item-choices {
  padding: 0.3rem;
}



/* Normally <li> are block level elements (take up the full width), but for this array of items, it should be arrange horizontally, so display:inline-block works best, allowing also to set width/height values for each one. */
div.flex-items-checked li.flex-item-checkbox {
  order: 1px solid goldenrod;
  display: inline-block;
  width: 20%;
}

div.button-container {
  width: 100%;
  padding: 8px;
  border: 1px solid #555;
}

.button {
  width: 30%;
}

div.dimensions {
  padding: 6px;
}
